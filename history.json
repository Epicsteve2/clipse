{"clipboardHistory":[{"value":"nohup go run main.go --start \u003e/dev/null 2\u003e\u00261 \u0026","recorded":"2024-02-11 16:44:35.275603773 +0000 UTC"},{"value":"Place","recorded":"2024-02-11 16:24:19.532176958 +0000 UTC"},{"value":"cmd := exec.Command(\"nohup\", \"sh\", \"-c\", \"go run \"+os.Args[0]+\" --start \u003e/dev/null 2\u003e\u00261 \u0026\")\n","recorded":"2024-02-11 16:23:35.834495821 +0000 UTC"},{"value":"\t\t\tcmd = exec.Command(\"nohup\", \"\u003e/dev/null\", \"2\u003e\u00261\", \"go\", \"run\", os.Args[0], \"--start\", \"\u0026\")\n","recorded":"2024-02-11 16:19:10.283459452 +0000 UTC"},{"value":"\u003e/dev/null 2\u003e\u00261","recorded":"2024-02-11 16:18:25.553095215 +0000 UTC"},{"value":"[]ClipboardItem ","recorded":"2024-02-11 16:14:56.641833571 +0000 UTC"},{"value":"package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/atotto/clipboard\"\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/list\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// ##################### LISTENER SECTION ####################### //\n// Data struct for storing clipboard strings\ntype Data struct {\n\tClipboardHistory []ClipboardItem `json:\"clipboardHistory\"`\n}\n\n// ClipboardItem struct for individual clipboard history item\ntype ClipboardItem struct {\n\tValue    string `json:\"value\"`\n\tRecorded string `json:\"recorded\"`\n}\n\nfunc runListener() error {\n\t// Listen for SIGINT (Ctrl+C) and SIGTERM signals to properly close the program\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, syscall.SIGINT, syscall.SIGTERM)\n\n\t// Load existing data from file, if any\n\tvar data Data\n\terr := loadDataFromFile(\"../history.json\", \u0026data)\n\tif err != nil {\n\t\tfmt.Println(\"Error loading data from file:\", err)\n\t}\n\n\t// Start a goroutine to continuously monitor clipboard changes\n\tgo func() {\n\t\tfor {\n\t\t\t// Get the current clipboard content\n\t\t\ttext, err := clipboard.ReadAll()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading clipboard:\", err)\n\t\t\t}\n\n\t\t\t// If clipboard content is not empty and not already in the list, add it\n\t\t\tif text != \"\" \u0026\u0026 !contains(data.ClipboardHistory, text) {\n\t\t\t\t// If the length exceeds 50, remove the oldest item\n\t\t\t\tif len(data.ClipboardHistory) \u003e= 50 {\n\t\t\t\t\tdata.ClipboardHistory = data.ClipboardHistory[1:] // Remove the oldest item (first element)\n\t\t\t\t}\n\t\t\t\ttimeNow := time.Now().UTC().String()\n\t\t\t\titem := ClipboardItem{Value: text, Recorded: timeNow}\n\t\t\t\tdata.ClipboardHistory = append([]ClipboardItem{item}, data.ClipboardHistory...)\n\t\t\t\tfmt.Println(\"Added to clipboard history:\", text)\n\n\t\t\t\t// Save data to file\n\t\t\t\terr := saveDataToFile(\"../history.json\", data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Println(\"Error saving data to file:\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for updates every 0.1 second\n\t\t\tduration := 100 * time.Millisecond / 10\n\t\t\ttime.Sleep(duration)\n\t\t}\n\t}()\n\n\tfmt.Println(\"Clipboard history listener running... Press Ctrl+C to exit.\")\n\n\t// Wait for SIGINT or SIGTERM signal\n\t\u003c-interrupt\n\tfmt.Println(\"Exiting...\")\n\treturn nil\n}\n\n// contains checks if a string exists in a slice of strings\nfunc contains(slice []ClipboardItem, str string) bool {\n\tfor _, item := range slice {\n\t\tif item.Value == str {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// loadDataFromFile loads data from a JSON file\nfunc loadDataFromFile(filename string, data *Data) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tdecoder := json.NewDecoder(file)\n\terr = decoder.Decode(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// saveDataToFile saves data to a JSON file\nfunc saveDataToFile(filename string, data Data) error {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tencoder := json.NewEncoder(file)\n\terr = encoder.Encode(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// ##################### LISTENER SECTION ####################### //\n\nvar (\n\tappStyle = lipgloss.NewStyle().Padding(1, 2)\n\n\ttitleStyle = lipgloss.NewStyle().\n\t\t\tForeground(lipgloss.Color(\"#FFFFFF\")).\n\t\t\tBackground(lipgloss.Color(\"#434C5E\")).\n\t\t\tPadding(0, 1)\n\n\tstatusMessageStyle = lipgloss.NewStyle().\n\t\t\t\tForeground(lipgloss.AdaptiveColor{Light: \"#04B575\", Dark: \"#04B575\"}).\n\t\t\t\tRender\n)\n\ntype item struct {\n\ttitle       string\n\ttitleFull   string\n\tdescription string\n}\n\nfunc (i item) Title() string       { return i.title }\nfunc (i item) TitleFull() string   { return i.titleFull }\nfunc (i item) Description() string { return i.description }\nfunc (i item) FilterValue() string { return i.title }\n\ntype listKeyMap struct {\n\ttoggleSpinner    key.Binding\n\ttoggleTitleBar   key.Binding\n\ttoggleStatusBar  key.Binding\n\ttogglePagination key.Binding\n\ttoggleHelpMenu   key.Binding\n}\n\nfunc newListKeyMap() *listKeyMap {\n\treturn \u0026listKeyMap{\n\n\t\ttoggleSpinner: key.NewBinding(\n\t\t\tkey.WithKeys(\"s\"),\n\t\t\tkey.WithHelp(\"s\", \"toggle spinner\"),\n\t\t),\n\t\ttoggleTitleBar: key.NewBinding(\n\t\t\tkey.WithKeys(\"T\"),\n\t\t\tkey.WithHelp(\"T\", \"toggle title\"),\n\t\t),\n\t\ttoggleStatusBar: key.NewBinding(\n\t\t\tkey.WithKeys(\"S\"),\n\t\t\tkey.WithHelp(\"S\", \"toggle status\"),\n\t\t),\n\t\ttogglePagination: key.NewBinding(\n\t\t\tkey.WithKeys(\"P\"),\n\t\t\tkey.WithHelp(\"P\", \"toggle pagination\"),\n\t\t),\n\t\ttoggleHelpMenu: key.NewBinding(\n\t\t\tkey.WithKeys(\"H\"),\n\t\t\tkey.WithHelp(\"H\", \"toggle help\"),\n\t\t),\n\t}\n}\n\ntype model struct {\n\tlist         list.Model\n\tkeys         *listKeyMap\n\tdelegateKeys *delegateKeyMap\n}\n\nfunc newModel() model {\n\tvar (\n\t\tdelegateKeys = newDelegateKeyMap()\n\t\tlistKeys     = newListKeyMap()\n\t)\n\n\t// Make initial list of items\n\tclipboardItems := getjsonData()\n\tvar entryItems []list.Item\n\tfor _, entry := range clipboardItems {\n\t\tshortenedVal := shorten(entry.Value)\n\t\titem := item{\n\t\t\ttitle:       shortenedVal,\n\t\t\ttitleFull:   entry.Value,\n\t\t\tdescription: \"Copied to clipboard: \" + entry.Recorded,\n\t\t}\n\t\tentryItems = append(entryItems, item)\n\t}\n\n\t// Setup list\n\tdelegate := newItemDelegate(delegateKeys)\n\tclipboardList := list.New(entryItems, delegate, 0, 0)\n\tclipboardList.Title = \"Clipboard History\"\n\tclipboardList.Styles.Title = titleStyle\n\tclipboardList.AdditionalFullHelpKeys = func() []key.Binding {\n\t\treturn []key.Binding{\n\t\t\tlistKeys.toggleSpinner,\n\t\t\tlistKeys.toggleTitleBar,\n\t\t\tlistKeys.toggleStatusBar,\n\t\t\tlistKeys.togglePagination,\n\t\t\tlistKeys.toggleHelpMenu,\n\t\t}\n\t}\n\n\treturn model{\n\t\tlist:         clipboardList,\n\t\tkeys:         listKeys,\n\t\tdelegateKeys: delegateKeys,\n\t}\n}\n\nfunc (m model) Init() tea.Cmd {\n\treturn tea.EnterAltScreen\n}\n\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\n\tswitch msg := msg.(type) {\n\tcase tea.WindowSizeMsg:\n\t\th, v := appStyle.GetFrameSize()\n\t\tm.list.SetSize(msg.Width-h, msg.Height-v)\n\n\tcase tea.KeyMsg:\n\t\t// Don't match any of the keys below if we're actively filtering.\n\t\tif m.list.FilterState() == list.Filtering {\n\t\t\tbreak\n\t\t}\n\n\t\tswitch {\n\t\tcase key.Matches(msg, m.keys.toggleSpinner):\n\t\t\tcmd := m.list.ToggleSpinner()\n\t\t\treturn m, cmd\n\n\t\tcase key.Matches(msg, m.keys.toggleTitleBar):\n\t\t\tv := !m.list.ShowTitle()\n\t\t\tm.list.SetShowTitle(v)\n\t\t\tm.list.SetShowFilter(v)\n\t\t\tm.list.SetFilteringEnabled(v)\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.toggleStatusBar):\n\t\t\tm.list.SetShowStatusBar(!m.list.ShowStatusBar())\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.togglePagination):\n\t\t\tm.list.SetShowPagination(!m.list.ShowPagination())\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.toggleHelpMenu):\n\t\t\tm.list.SetShowHelp(!m.list.ShowHelp())\n\t\t\treturn m, nil\n\n\t\t}\n\t}\n\n\t// This will also call our delegate's update function.\n\tnewListModel, cmd := m.list.Update(msg)\n\tm.list = newListModel\n\tcmds = append(cmds, cmd)\n\n\treturn m, tea.Batch(cmds...)\n}\n\nfunc (m model) View() string {\n\treturn appStyle.Render(m.list.View())\n}\n\nfunc shorten(s string) string {\n\tmaxLen := 30 // Define your max length here\n\tif len(s) \u003c= maxLen {\n\t\treturn strings.ReplaceAll(s, \"\\n\", \" \")\n\t}\n\treturn strings.ReplaceAll(s[:maxLen-3], \"\\n\", \" \") + \"...\"\n}\n\n// NEW ITEM DELEGATE SECTION\nfunc newItemDelegate(keys *delegateKeyMap) list.DefaultDelegate {\n\td := list.NewDefaultDelegate()\n\n\td.UpdateFunc = func(msg tea.Msg, m *list.Model) tea.Cmd {\n\t\tvar title string\n\t\tvar fullValue string\n\n\t\tif i, ok := m.SelectedItem().(item); ok {\n\t\t\ttitle = i.Title()\n\t\t\tfullValue = i.TitleFull()\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch msg := msg.(type) {\n\t\tcase tea.KeyMsg:\n\t\t\tswitch {\n\t\t\tcase key.Matches(msg, keys.choose):\n\t\t\t\terr := clipboard.WriteAll(fullValue)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\treturn m.NewStatusMessage(statusMessageStyle(\"Copied to clipboard: \" + title))\n\n\t\t\tcase key.Matches(msg, keys.remove):\n\t\t\t\tindex := m.Index()\n\t\t\t\tm.RemoveItem(index)\n\t\t\t\tif len(m.Items()) == 0 {\n\t\t\t\t\tkeys.remove.SetEnabled(false)\n\t\t\t\t}\n\t\t\t\terr := deleteJsonItem(fullValue)\n\t\t\t\tif err != nil {\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t\treturn m.NewStatusMessage(statusMessageStyle(\"Deleted: \" + title))\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\thelp := []key.Binding{keys.choose, keys.remove}\n\n\td.ShortHelpFunc = func() []key.Binding {\n\t\treturn help\n\t}\n\n\td.FullHelpFunc = func() [][]key.Binding {\n\t\treturn [][]key.Binding{help}\n\t}\n\n\treturn d\n}\n\ntype delegateKeyMap struct {\n\tchoose key.Binding\n\tremove key.Binding\n}\n\n// Additional short help entries. This satisfies the help.KeyMap interface and\n// is entirely optional.\nfunc (d delegateKeyMap) ShortHelp() []key.Binding {\n\treturn []key.Binding{\n\t\td.choose,\n\t\td.remove,\n\t}\n}\n\n// Additional full help entries. This satisfies the help.KeyMap interface and\n// is entirely optional.\nfunc (d delegateKeyMap) FullHelp() [][]key.Binding {\n\treturn [][]key.Binding{\n\t\t{\n\t\t\td.choose,\n\t\t\td.remove,\n\t\t},\n\t}\n}\n\nfunc newDelegateKeyMap() *delegateKeyMap {\n\treturn \u0026delegateKeyMap{\n\t\tchoose: key.NewBinding(\n\t\t\tkey.WithKeys(\"enter\"),\n\t\t\tkey.WithHelp(\"enter\", \"copy\"),\n\t\t),\n\t\tremove: key.NewBinding(\n\t\t\tkey.WithKeys(\"x\", \"backspace\"),\n\t\t\tkey.WithHelp(\"x\", \"delete\"),\n\t\t),\n\t}\n}\n\ntype ClipboardEntry struct {\n\tValue    string `json:\"value\"`\n\tRecorded string `json:\"recorded\"`\n}\n\ntype ClipboardHistory struct {\n\tClipboardHistory []ClipboardEntry `json:\"clipboardHistory\"`\n}\n\nfunc getjsonData() []ClipboardEntry {\n\tfile, err := os.Open(\"../history.json\")\n\tif err != nil {\n\t\tfmt.Println(\"error opening file:\", err)\n\t\tfile.Close()\n\t}\n\n\t// Decode JSON from the file\n\tvar data ClipboardHistory\n\tif err := json.NewDecoder(file).Decode(\u0026data); err != nil {\n\t\tfmt.Println(\"Error decoding JSON:\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Extract clipboard history items\n\tclipboardHistory := data.ClipboardHistory\n\n\treturn clipboardHistory\n\n}\n\nfunc deleteJsonItem(item string) error {\n\tfilePath := \"../history.json\"\n\tfileContent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error reading file: %w\", err)\n\t}\n\n\tvar data ClipboardHistory\n\tif err := json.Unmarshal(fileContent, \u0026data); err != nil {\n\t\treturn fmt.Errorf(\"error unmarshalling JSON: %w\", err)\n\t}\n\n\tvar updatedClipboardHistory []ClipboardEntry\n\tfor _, entry := range data.ClipboardHistory {\n\t\tif entry.Value != item {\n\t\t\tupdatedClipboardHistory = append(updatedClipboardHistory, entry)\n\t\t}\n\t}\n\n\tupdatedData := ClipboardHistory{\n\t\tClipboardHistory: updatedClipboardHistory,\n\t}\n\tupdatedJSON, err := json.Marshal(updatedData)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshalling JSON: %w\", err)\n\t}\n\n\t// Write the updated JSON back to the file\n\tif err := os.WriteFile(filePath, updatedJSON, 0644); err != nil {\n\t\treturn fmt.Errorf(\"error writing file: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\t// cmd args\n\thelp := \"--help\"\n\tlisten := \"--listen\"\n\tclear := \"--clear\"\n\tlistenStart := \"--start\"\n\n\tif len(os.Args) \u003e 1 {\n\t\tswitch os.Args[1] {\n\t\tcase help:\n\t\t\tfmt.Println(\"Place holder\")\n\t\t\tos.Exit(0)\n\t\tcase listen:\n\t\t\tcmd := exec.Command(\"pkill\", os.Args[0])\n\t\t\tcmd.Run() // Kill existing clipboard processes\n\t\t\tcmd = exec.Command(\"nohup\", \"go\", \"run\", os.Args[0], \"--start\", \"\u0026\")\n\t\t\tif err := cmd.Start(); err != nil {\n\t\t\t\tfmt.Println(\"Error starting clipboard listener:\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\tfmt.Println(\"Starting clipboard listener...\")\n\t\t\tos.Exit(0)\n\t\tcase clear:\n\t\t\tfmt.Println(\"Place holder\")\n\t\t\tos.Exit(0)\n\t\tcase listenStart:\n\t\t\terr := runListener()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t}\n\t\t\tos.Exit(0)\n\t\tdefault:\n\t\t\tfmt.Println(\"Arg not recognised. Try `clipboard --help` for more details.\")\n\t\t\tos.Exit(0)\n\t\t}\n\t}\n\n\tif _, err := tea.NewProgram(newModel()).Run(); err != nil {\n\t\tfmt.Println(\"Error opening clipboard:\", err)\n\t\tos.Exit(1)\n\t}\n}\n","recorded":"2024-02-11 16:14:28.864582448 +0000 UTC"},{"value":"recognised","recorded":"2024-02-11 16:07:04.067690404 +0000 UTC"},{"value":"starting","recorded":"2024-02-11 16:05:18.014522067 +0000 UTC"},{"value":"Command","recorded":"2024-02-11 16:04:27.701673542 +0000 UTC"},{"value":"- Config added to json file, adjustable with CLI args","recorded":"2024-02-11 16:04:18.423020765 +0000 UTC"},{"value":"ok how does this sound: I have a single binary called \"clipboard\" that takes cli arguments. When the name of the binary alone is entered it will display the clipboard list, If \"clipboard --listen\" is added the program will use go's exec lib to call \"nohup clipboard --listen\", starting the listener so the user is then free to call \"clipboard\" for opening the list as they please. Would there be a problem with the binary code calling a command to run itself?","recorded":"2024-02-11 14:44:08.752055376 +0000 UTC"},{"value":"kill \u003cPID\u003e\n","recorded":"2024-02-11 14:34:39.125092936 +0000 UTC"},{"value":"ps aux | grep main.go\n","recorded":"2024-02-11 14:34:30.621114802 +0000 UTC"},{"value":"nohup go run main.go \u0026","recorded":"2024-02-11 14:34:01.27255148 +0000 UTC"},{"value":"encoding","recorded":"2024-02-11 14:33:33.564077506 +0000 UTC"},{"value":"atotto","recorded":"2024-02-11 14:33:25.36957862 +0000 UTC"},{"value":"clipboardHistory","recorded":"2024-02-11 14:33:16.172215298 +0000 UTC"},{"value":"recorded","recorded":"2024-02-11 14:32:15.451092505 +0000 UTC"},{"value":"json","recorded":"2024-02-11 14:32:12.811889055 +0000 UTC"},{"value":"\"../history.json","recorded":"2024-02-11 14:22:11.797432976 +0000 UTC"},{"value":"data.ClipboardHistory = append([]ClipboardItem{item}, data.ClipboardHistory...)\n","recorded":"2024-02-11 14:21:57.801495962 +0000 UTC"},{"value":"./main.go:54:56: cannot use item (variable of type ClipboardItem) as map[string]string value in array or slice literal\n./main.go:54:63: cannot use data.ClipboardHistory (variable of type []ClipboardItem) as []map[string]string value in argument to append","recorded":"2024-02-11 14:18:12.089903323 +0000 UTC"},{"value":"Newvalue","recorded":"12/01/02"},{"value":"string","recorded":"2024-02-10 23:46:53.330961 +0000 UTC"},{"value":"var (\n\tappStyle = lipgloss.NewStyle().Padding(1, 2)\n\n\ttitleStyle = lipgloss.NewStyle().\n\t\t\tForeground(lipgloss.Color(\"#8FBCBB\")).\n\t\t\tBackground(lipgloss.Color(\"#8FBCBB\")).\n\t\t\tPadding(0, 1)\n\n\tstatusMessageStyle = lipgloss.NewStyle().\n\t\t\t\tForeground(lipgloss.AdaptiveColor{Light: \"#04B575\", Dark: \"#04B575\"}).\n\t\t\t\tRender\n)\n\ntype item struct {\n\ttitle       string\n\tdescription string\n}\n\nfunc (i item) Title() string       { return i.title }\nfunc (i item) Description() string { return i.description }\nfunc (i item) FilterValue() string { return i.title }\n\ntype listKeyMap struct {\n\ttoggleSpinner    key.Binding\n\ttoggleTitleBar   key.Binding\n\ttoggleStatusBar  key.Binding\n\ttogglePagination key.Binding\n\ttoggleHelpMenu   key.Binding\n}\n\nfunc newListKeyMap() *listKeyMap {\n\treturn \u0026listKeyMap{\n\n\t\ttoggleSpinner: key.NewBinding(\n\t\t\tkey.WithKeys(\"s\"),\n\t\t\tkey.WithHelp(\"s\", \"toggle spinner\"),\n\t\t),\n\t\ttoggleTitleBar: key.NewBinding(\n\t\t\tkey.WithKeys(\"T\"),\n\t\t\tkey.WithHelp(\"T\", \"toggle title\"),\n\t\t),\n\t\ttoggleStatusBar: key.NewBinding(\n\t\t\tkey.WithKeys(\"S\"),\n\t\t\tkey.WithHelp(\"S\", \"toggle status\"),\n\t\t),\n\t\ttogglePagination: key.NewBinding(\n\t\t\tkey.WithKeys(\"P\"),\n\t\t\tkey.WithHelp(\"P\", \"toggle pagination\"),\n\t\t),\n\t\ttoggleHelpMenu: key.NewBinding(\n\t\t\tkey.WithKeys(\"H\"),\n\t\t\tkey.WithHelp(\"H\", \"toggle help\"),\n\t\t),\n\t}\n}\n\ntype model struct {\n\tlist          list.Model\n\t//itemGenerator *randomItemGenerator\n\tkeys          *listKeyMap\n\tdelegateKeys  *delegateKeyMap\n}\n\nfunc newModel() model {\n\tvar (\n\t\t//itemGenerator randomItemGenerator\n\t\tdelegateKeys  = newDelegateKeyMap()\n\t\tlistKeys      = newListKeyMap()\n\t)\n\n\t// Make initial list of items\n\tclipboardItems := getjsonData()\n\tvar entryItems []list.Item\n\tfor _, entry := range clipboardItems {\n\t\titem := item{\n            title:       entry.Value,\n            description: \"Copied to clipboard: \" + entry.Recorded,\n        }\n\t\tentryItems = append(entryItems, item)\n\t}\n\n\n\t// Setup list\n\tdelegate := newItemDelegate(delegateKeys)\n\tclipboardList := list.New(entryItems, delegate, 0, 0)\n\tclipboardList.Title = \"Clipboard History\"\n\tclipboardList.Styles.Title = titleStyle\n\tclipboardList.AdditionalFullHelpKeys = func() []key.Binding {\n\t\treturn []key.Binding{\n\t\t\tlistKeys.toggleSpinner,\n\t\t\tlistKeys.toggleTitleBar,\n\t\t\tlistKeys.toggleStatusBar,\n\t\t\tlistKeys.togglePagination,\n\t\t\tlistKeys.toggleHelpMenu,\n\t\t}\n\t}\n\n\treturn model{\n\t\tlist:          clipboardList,\n\t\tkeys:          listKeys,\n\t\tdelegateKeys:  delegateKeys,\n\t}\n}\n\nfunc (m model) Init() tea.Cmd {\n\treturn tea.EnterAltScreen\n}\n\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\n\tswitch msg := msg.(type) {\n\tcase tea.WindowSizeMsg:\n\t\th, v := appStyle.GetFrameSize()\n\t\tm.list.SetSize(msg.Width-h, msg.Height-v)\n\n\tcase tea.KeyMsg:\n\t\t// Don't match any of the keys below if we're actively filtering.\n\t\tif m.list.FilterState() == list.Filtering {\n\t\t\tbreak\n\t\t}\n\n\t\tswitch {\n\t\tcase key.Matches(msg, m.keys.toggleSpinner):\n\t\t\tcmd := m.list.ToggleSpinner()\n\t\t\treturn m, cmd\n\n\t\tcase key.Matches(msg, m.keys.toggleTitleBar):\n\t\t\tv := !m.list.ShowTitle()\n\t\t\tm.list.SetShowTitle(v)\n\t\t\tm.list.SetShowFilter(v)\n\t\t\tm.list.SetFilteringEnabled(v)\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.toggleStatusBar):\n\t\t\tm.list.SetShowStatusBar(!m.list.ShowStatusBar())\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.togglePagination):\n\t\t\tm.list.SetShowPagination(!m.list.ShowPagination())\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.toggleHelpMenu):\n\t\t\tm.list.SetShowHelp(!m.list.ShowHelp())\n\t\t\treturn m, nil\n\n\t\t}\n\t}\n\n\t// This will also call our delegate's update function.\n\tnewListModel, cmd := m.list.Update(msg)\n\tm.list = newListModel\n\tcmds = append(cmds, cmd)\n\n\treturn m, tea.Batch(cmds...)\n}\n\nfunc (m model) View() string {\n\treturn appStyle.Render(m.list.View())","recorded":"2024-02-11 00:17:01.75482 +0000 UTC"},{"value":"package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"time\"\n\t\"encoding/json\"\n\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/list\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/atotto/clipboard\"\n\n)\n\nvar (\n\tappStyle = lipgloss.NewStyle().Padding(1, 2)\n\n\ttitleStyle = lipgloss.NewStyle().\n\t\t\tForeground(lipgloss.Color(\"#8FBCBB\")).\n\t\t\tBackground(lipgloss.Color(\"#8FBCBB\")).\n\t\t\tPadding(0, 1)\n\n\tstatusMessageStyle = lipgloss.NewStyle().\n\t\t\t\tForeground(lipgloss.AdaptiveColor{Light: \"#04B575\", Dark: \"#04B575\"}).\n\t\t\t\tRender\n)\n\ntype item struct {\n\ttitle       string\n\tdescription string\n}\n\nfunc (i item) Title() string       { return i.title }\nfunc (i item) Description() string { return i.description }\nfunc (i item) FilterValue() string { return i.title }\n\ntype listKeyMap struct {\n\ttoggleSpinner    key.Binding\n\ttoggleTitleBar   key.Binding\n\ttoggleStatusBar  key.Binding\n\ttogglePagination key.Binding\n\ttoggleHelpMenu   key.Binding\n}\n\nfunc newListKeyMap() *listKeyMap {\n\treturn \u0026listKeyMap{\n\n\t\ttoggleSpinner: key.NewBinding(\n\t\t\tkey.WithKeys(\"s\"),\n\t\t\tkey.WithHelp(\"s\", \"toggle spinner\"),\n\t\t),\n\t\ttoggleTitleBar: key.NewBinding(\n\t\t\tkey.WithKeys(\"T\"),\n\t\t\tkey.WithHelp(\"T\", \"toggle title\"),\n\t\t),\n\t\ttoggleStatusBar: key.NewBinding(\n\t\t\tkey.WithKeys(\"S\"),\n\t\t\tkey.WithHelp(\"S\", \"toggle status\"),\n\t\t),\n\t\ttogglePagination: key.NewBinding(\n\t\t\tkey.WithKeys(\"P\"),\n\t\t\tkey.WithHelp(\"P\", \"toggle pagination\"),\n\t\t),\n\t\ttoggleHelpMenu: key.NewBinding(\n\t\t\tkey.WithKeys(\"H\"),\n\t\t\tkey.WithHelp(\"H\", \"toggle help\"),\n\t\t),\n\t}\n}\n\ntype model struct {\n\tlist          list.Model\n\t//itemGenerator *randomItemGenerator\n\tkeys          *listKeyMap\n\tdelegateKeys  *delegateKeyMap\n}\n\nfunc newModel() model {\n\tvar (\n\t\t//itemGenerator randomItemGenerator\n\t\tdelegateKeys  = newDelegateKeyMap()\n\t\tlistKeys      = newListKeyMap()\n\t)\n\n\t// Make initial list of items\n\tclipboardItems := getjsonData()\n\tvar entryItems []list.Item\n\tfor _, entry := range clipboardItems {\n\t\titem := item{\n            title:       entry.Value,\n            description: \"Copied to clipboard: \" + entry.Recorded,\n        }\n\t\tentryItems = append(entryItems, item)\n\t}\n\n\n\t// Setup list\n\tdelegate := newItemDelegate(delegateKeys)\n\tclipboardList := list.New(entryItems, delegate, 0, 0)\n\tclipboardList.Title = \"Clipboard History\"\n\tclipboardList.Styles.Title = titleStyle\n\tclipboardList.AdditionalFullHelpKeys = func() []key.Binding {\n\t\treturn []key.Binding{\n\t\t\tlistKeys.toggleSpinner,\n\t\t\tlistKeys.toggleTitleBar,\n\t\t\tlistKeys.toggleStatusBar,\n\t\t\tlistKeys.togglePagination,\n\t\t\tlistKeys.toggleHelpMenu,\n\t\t}\n\t}\n\n\treturn model{\n\t\tlist:          clipboardList,\n\t\tkeys:          listKeys,\n\t\tdelegateKeys:  delegateKeys,\n\t}\n}\n\nfunc (m model) Init() tea.Cmd {\n\treturn tea.EnterAltScreen\n}\n\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\n\tswitch msg := msg.(type) {\n\tcase tea.WindowSizeMsg:\n\t\th, v := appStyle.GetFrameSize()\n\t\tm.list.SetSize(msg.Width-h, msg.Height-v)\n\n\tcase tea.KeyMsg:\n\t\t// Don't match any of the keys below if we're actively filtering.\n\t\tif m.list.FilterState() == list.Filtering {\n\t\t\tbreak\n\t\t}\n\n\t\tswitch {\n\t\tcase key.Matches(msg, m.keys.toggleSpinner):\n\t\t\tcmd := m.list.ToggleSpinner()\n\t\t\treturn m, cmd\n\n\t\tcase key.Matches(msg, m.keys.toggleTitleBar):\n\t\t\tv := !m.list.ShowTitle()\n\t\t\tm.list.SetShowTitle(v)\n\t\t\tm.list.SetShowFilter(v)\n\t\t\tm.list.SetFilteringEnabled(v)\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.toggleStatusBar):\n\t\t\tm.list.SetShowStatusBar(!m.list.ShowStatusBar())\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.togglePagination):\n\t\t\tm.list.SetShowPagination(!m.list.ShowPagination())\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.toggleHelpMenu):\n\t\t\tm.list.SetShowHelp(!m.list.ShowHelp())\n\t\t\treturn m, nil\n\n\t\t}\n\t}\n\n\t// This will also call our delegate's update function.\n\tnewListModel, cmd := m.list.Update(msg)\n\tm.list = newListModel\n\tcmds = append(cmds, cmd)\n\n\treturn m, tea.Batch(cmds...)\n}\n\nfunc (m model) View() string {\n\treturn appStyle.Render(m.list.View())\n}\n\n\n// NEW ITEM DELEGATE SECTION\nfunc newItemDelegate(keys *delegateKeyMap) list.DefaultDelegate {\n\td := list.NewDefaultDelegate()\n\n\td.UpdateFunc = func(msg tea.Msg, m *list.Model) tea.Cmd {\n\t\tvar title string\n\n\t\tif i, ok := m.SelectedItem().(item); ok {\n\t\t\ttitle = i.Title()\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch msg := msg.(type) {\n\t\tcase tea.KeyMsg:\n\t\t\tswitch {\n\t\t\tcase key.Matches(msg, keys.choose):\n\t\t\t\terr := clipboard.WriteAll(title)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\treturn m.NewStatusMessage(statusMessageStyle(\"Copied to clipboard: \" + title))\n\n\t\t\tcase key.Matches(msg, keys.remove):\n\t\t\t\tindex := m.Index()\n\t\t\t\tm.RemoveItem(index)\n\t\t\t\tif len(m.Items()) == 0 {\n\t\t\t\t\tkeys.remove.SetEnabled(false)\n\t\t\t\t}\n\t\t\t\terr := deleteJsonItem(title)\n\t\t\t\tif err != nil {\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t\treturn m.NewStatusMessage(statusMessageStyle(\"Deleted: \" + title))\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\thelp := []key.Binding{keys.choose, keys.remove}\n\n\td.ShortHelpFunc = func() []key.Binding {\n\t\treturn help\n\t}\n\n\td.FullHelpFunc = func() [][]key.Binding {\n\t\treturn [][]key.Binding{help}\n\t}\n\n\treturn d\n}\n\ntype delegateKeyMap struct {\n\tchoose key.Binding\n\tremove key.Binding\n}\n\n// Additional short help entries. This satisfies the help.KeyMap interface and\n// is entirely optional.\nfunc (d delegateKeyMap) ShortHelp() []key.Binding {\n\treturn []key.Binding{\n\t\td.choose,\n\t\td.remove,\n\t}\n}\n\n// Additional full help entries. This satisfies the help.KeyMap interface and\n// is entirely optional.\nfunc (d delegateKeyMap) FullHelp() [][]key.Binding {\n\treturn [][]key.Binding{\n\t\t{\n\t\t\td.choose,\n\t\t\td.remove,\n\t\t},\n\t}\n}\n\nfunc newDelegateKeyMap() *delegateKeyMap {\n\treturn \u0026delegateKeyMap{\n\t\tchoose: key.NewBinding(\n\t\t\tkey.WithKeys(\"enter\"),\n\t\t\tkey.WithHelp(\"enter\", \"copy\"),\n\t\t),\n\t\tremove: key.NewBinding(\n\t\t\tkey.WithKeys(\"x\", \"backspace\"),\n\t\t\tkey.WithHelp(\"x\", \"delete\"),\n\t\t),\n\t}\n}\n\ntype ClipboardEntry struct {\n    Value   string `json:\"value\"`\n    Recorded string `json:\"recorded\"`\n}\n\ntype ClipboardHistory struct {\n    ClipboardHistory []ClipboardEntry `json:\"clipboardHistory\"`\n}\n\nfunc getjsonData() []ClipboardEntry {\n\tfile, err := os.Open(\"history.json\")\n\tif err != nil {\n\t\tfmt.Println(\"error opening file:\", err)\n\t\tfile.Close()\n\t}\n\n\t// Decode JSON from the file\n\tvar data ClipboardHistory\n\tif err := json.NewDecoder(file).Decode(\u0026data); err != nil {\n\t\tfmt.Println(\"Error decoding JSON:\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Extract clipboard history items\n\tclipboardHistory := data.ClipboardHistory\n\n\treturn clipboardHistory\n\n}\n\nfunc deleteJsonItem(item string) error {\n    filePath := \"history.json\"\n    fileContent, err := os.ReadFile(filePath)\n    if err != nil {\n        return fmt.Errorf(\"error reading file: %w\", err)\n    }\n\n    var data ClipboardHistory\n    if err := json.Unmarshal(fileContent, \u0026data); err != nil {\n        return fmt.Errorf(\"error unmarshalling JSON: %w\", err)\n    }\n\n    var updatedClipboardHistory []ClipboardEntry\n    for _, entry := range data.ClipboardHistory {\n        if entry.Value != item {\n            updatedClipboardHistory = append(updatedClipboardHistory, entry)\n        }\n    }\n\n    updatedData := ClipboardHistory{\n        ClipboardHistory: updatedClipboardHistory,\n    }\n    updatedJSON, err := json.Marshal(updatedData)\n    if err != nil {\n        return fmt.Errorf(\"error marshalling JSON: %w\", err)\n    }\n\n    // Write the updated JSON back to the file\n    if err := os.WriteFile(filePath, updatedJSON, 0644); err != nil {\n        return fmt.Errorf(\"error writing file: %w\", err)\n    }\n\n    return nil\n}\n\nfunc main() {\n\trand.Seed(time.Now().UTC().UnixNano())\n\tif _, err := tea.NewProgram(newModel()).Run(); err != nil {\n\t\tfmt.Println(\"Error opening clipboard:\", err)\n\t\tos.Exit(1)\n\t}\n}","recorded":"2024-02-11 00:17:36.874749 +0000 UTC"},{"value":"titleFull","recorded":"2024-02-11 00:24:25.612067 +0000 UTC"},{"value":"entry.Title","recorded":"2024-02-11 00:25:38.881158 +0000 UTC"},{"value":" Copied to clipboard: 2024-02-11 00:25:38.881158 +0000 UTC","recorded":"2024-02-11 00:28:17.838988 +0000 UTC"},{"value":"Copied to clipboard: 2024-02-11 00:25:38.881158 +0000 UTC Copied to clipboard: 2024-02-11 00:25:38.881158 +0000 UTC Copied to clipboard: 2024-02-11 00:25:38.881158 +0000 UTC","recorded":"2024-02-11 00:28:29.213859 +0000 UTC"},{"value":"Copied to clipboard: 2024-02-11 00:25:38.881158 +0000 \n\t\tUTC Copied to clipboard: 2024-02-11 00:25:38.881158 +0000 UTC Copied to clipboard: 2024-02-11 00:25:38.881158 +0000 UTC","recorded":"2024-02-11 00:29:22.881068 +0000 UTC"},{"value":"package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"time\"\n\t\"encoding/json\"\n\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/list\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/atotto/clipboard\"\n\n)\n\nvar (\n\tappStyle = lipgloss.NewStyle().Padding(1, 2)\n\n\ttitleStyle = lipgloss.NewStyle().\n\t\t\tForeground(lipgloss.Color(\"#8FBCBB\")).\n\t\t\tBackground(lipgloss.Color(\"#8FBCBB\")).\n\t\t\tPadding(0, 1)\n\n\tstatusMessageStyle = lipgloss.NewStyle().\n\t\t\t\tForeground(lipgloss.AdaptiveColor{Light: \"#04B575\", Dark: \"#04B575\"}).\n\t\t\t\tRender\n)\n\ntype item struct {\n\ttitle       string\n\tdescription string\n}\n\nfunc (i item) Title() string       { return i.title }\nfunc (i item) Description() string { return i.description }\nfunc (i item) FilterValue() string { return i.title }\n\ntype listKeyMap struct {\n\ttoggleSpinner    key.Binding\n\ttoggleTitleBar   key.Binding\n\ttoggleStatusBar  key.Binding\n\ttogglePagination key.Binding\n\ttoggleHelpMenu   key.Binding\n}\n\nfunc newListKeyMap() *listKeyMap {\n\treturn \u0026listKeyMap{\n\n\t\ttoggleSpinner: key.NewBinding(\n\t\t\tkey.WithKeys(\"s\"),\n\t\t\tkey.WithHelp(\"s\", \"toggle spinner\"),\n\t\t),\n\t\ttoggleTitleBar: key.NewBinding(\n\t\t\tkey.WithKeys(\"T\"),\n\t\t\tkey.WithHelp(\"T\", \"toggle title\"),\n\t\t),\n\t\ttoggleStatusBar: key.NewBinding(\n\t\t\tkey.WithKeys(\"S\"),\n\t\t\tkey.WithHelp(\"S\", \"toggle status\"),\n\t\t),\n\t\ttogglePagination: key.NewBinding(\n\t\t\tkey.WithKeys(\"P\"),\n\t\t\tkey.WithHelp(\"P\", \"toggle pagination\"),\n\t\t),\n\t\ttoggleHelpMenu: key.NewBinding(\n\t\t\tkey.WithKeys(\"H\"),\n\t\t\tkey.WithHelp(\"H\", \"toggle help\"),\n\t\t),\n\t}\n}\n\ntype model struct {\n\tlist          list.Model\n\t//itemGenerator *randomItemGenerator\n\tkeys          *listKeyMap\n\tdelegateKeys  *delegateKeyMap\n}\n\nfunc newModel() model {\n\tvar (\n\t\t//itemGenerator randomItemGenerator\n\t\tdelegateKeys  = newDelegateKeyMap()\n\t\tlistKeys      = newListKeyMap()\n\t)\n\n\t// Make initial list of items\n\tclipboardItems := getjsonData()\n\tvar entryItems []list.Item\n\tfor _, entry := range clipboardItems {\n\t\titem := item{\n            title:       entry.Value,\n            description: \"Copied to clipboard: \" + entry.Recorded,\n        }\n\t\tentryItems = append(entryItems, item)\n\t}\n\n\n\t// Setup list\n\tdelegate := newItemDelegate(delegateKeys)\n\tclipboardList := list.New(entryItems, delegate, 0, 0)\n\tclipboardList.Title = \"Clipboard History\"\n\tclipboardList.Styles.Title = titleStyle\n\tclipboardList.AdditionalFullHelpKeys = func() []key.Binding {\n\t\treturn []key.Binding{\n\t\t\tlistKeys.toggleSpinner,\n\t\t\tlistKeys.toggleTitleBar,\n\t\t\tlistKeys.toggleStatusBar,\n\t\t\tlistKeys.togglePagination,\n\t\t\tlistKeys.toggleHelpMenu,\n\t\t}\n\t}\n\n\treturn model{\n\t\tlist:          clipboardList,\n\t\tkeys:          listKeys,\n\t\tdelegateKeys:  delegateKeys,\n\t}\n}\n\nfunc (m model) Init() tea.Cmd {\n\treturn tea.EnterAltScreen\n}\n\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\n\tswitch msg := msg.(type) {\n\tcase tea.WindowSizeMsg:\n\t\th, v := appStyle.GetFrameSize()\n\t\tm.list.SetSize(msg.Width-h, msg.Height-v)\n\n\tcase tea.KeyMsg:\n\t\t// Don't match any of the keys below if we're actively filtering.\n\t\tif m.list.FilterState() == list.Filtering {\n\t\t\tbreak\n\t\t}\n\n\t\tswitch {\n\t\tcase key.Matches(msg, m.keys.toggleSpinner):\n\t\t\tcmd := m.list.ToggleSpinner()\n\t\t\treturn m, cmd\n\n\t\tcase key.Matches(msg, m.keys.toggleTitleBar):\n\t\t\tv := !m.list.ShowTitle()\n\t\t\tm.list.SetShowTitle(v)\n\t\t\tm.list.SetShowFilter(v)\n\t\t\tm.list.SetFilteringEnabled(v)\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.toggleStatusBar):\n\t\t\tm.list.SetShowStatusBar(!m.list.ShowStatusBar())\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.togglePagination):\n\t\t\tm.list.SetShowPagination(!m.list.ShowPagination())\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, m.keys.toggleHelpMenu):\n\t\t\tm.list.SetShowHelp(!m.list.ShowHelp())\n\t\t\treturn m, nil\n\n\t\t}\n\t}\n\n\t// This will also call our delegate's update function.\n\tnewListModel, cmd := m.list.Update(msg)\n\tm.list = newListModel\n\tcmds = append(cmds, cmd)\n\n\treturn m, tea.Batch(cmds...)\n}\n\nfunc (m model) View() string {\n\treturn appStyle.Render(m.list.View())\n}\n\n\n// NEW ITEM DELEGATE SECTION\nfunc newItemDelegate(keys *delegateKeyMap) list.DefaultDelegate {\n\td := list.NewDefaultDelegate()\n\n\td.UpdateFunc = func(msg tea.Msg, m *list.Model) tea.Cmd {\n\t\tvar title string\n\n\t\tif i, ok := m.SelectedItem().(item); ok {\n\t\t\ttitle = i.Title()\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\t\t\n\t\tswitch msg := msg.(type) {\n\t\tcase tea.KeyMsg:\n\t\t\tswitch {\n\t\t\tcase key.Matches(msg, keys.choose):\n\t\t\t\terr := clipboard.WriteAll(title)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\treturn m.NewStatusMessage(statusMessageStyle(\"Copied to clipboard: \" + title))\n\n\t\t\tcase key.Matches(msg, keys.remove):\n\t\t\t\tindex := m.Index()\n\t\t\t\tm.RemoveItem(index)\n\t\t\t\tif len(m.Items()) == 0 {\n\t\t\t\t\tkeys.remove.SetEnabled(false)\n\t\t\t\t}\n\t\t\t\terr := deleteJsonItem(title)\n\t\t\t\tif err != nil {\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t\treturn m.NewStatusMessage(statusMessageStyle(\"Deleted: \" + title))\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\thelp := []key.Binding{keys.choose, keys.remove}\n\n\td.ShortHelpFunc = func() []key.Binding {\n\t\treturn help\n\t}\n\n\td.FullHelpFunc = func() [][]key.Binding {\n\t\treturn [][]key.Binding{help}\n\t}\n\n\treturn d\n}\n\ntype delegateKeyMap struct {\n\tchoose key.Binding\n\tremove key.Binding\n}\n\n// Additional short help entries. This satisfies the help.KeyMap interface and\n// is entirely optional.\nfunc (d delegateKeyMap) ShortHelp() []key.Binding {\n\treturn []key.Binding{\n\t\td.choose,\n\t\td.remove,\n\t}\n}\n\n// Additional full help entries. This satisfies the help.KeyMap interface and\n// is entirely optional.\nfunc (d delegateKeyMap) FullHelp() [][]key.Binding {\n\treturn [][]key.Binding{\n\t\t{\n\t\t\td.choose,\n\t\t\td.remove,\n\t\t},\n\t}\n}\n\nfunc newDelegateKeyMap() *delegateKeyMap {\n\treturn \u0026delegateKeyMap{\n\t\tchoose: key.NewBinding(\n\t\t\tkey.WithKeys(\"enter\"),\n\t\t\tkey.WithHelp(\"enter\", \"copy\"),\n\t\t),\n\t\tremove: key.NewBinding(\n\t\t\tkey.WithKeys(\"x\", \"backspace\"),\n\t\t\tkey.WithHelp(\"x\", \"delete\"),\n\t\t),\n\t}\n}\n\ntype ClipboardEntry struct {\n    Value   string `json:\"value\"`\n    Recorded string `json:\"recorded\"`\n}\n\ntype ClipboardHistory struct {\n    ClipboardHistory []ClipboardEntry `json:\"clipboardHistory\"`\n}\n\nfunc getjsonData() []ClipboardEntry {\n\tfile, err := os.Open(\"history.json\")\n\tif err != nil {\n\t\tfmt.Println(\"error opening file:\", err)\n\t\tfile.Close()\n\t}\n\n\t// Decode JSON from the file\n\tvar data ClipboardHistory\n\tif err := json.NewDecoder(file).Decode(\u0026data); err != nil {\n\t\tfmt.Println(\"Error decoding JSON:\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Extract clipboard history items\n\tclipboardHistory := data.ClipboardHistory\n\n\treturn clipboardHistory\n\n}\n\nfunc deleteJsonItem(item string) error {\n    filePath := \"history.json\"\n    fileContent, err := os.ReadFile(filePath)\n    if err != nil {\n        return fmt.Errorf(\"error reading file: %w\", err)\n    }\n\n    var data ClipboardHistory\n    if err := json.Unmarshal(fileContent, \u0026data); err != nil {\n        return fmt.Errorf(\"error unmarshalling JSON: %w\", err)\n    }\n\n    var updatedClipboardHistory []ClipboardEntry\n    for _, entry := range data.ClipboardHistory {\n        if entry.Value != item {\n            updatedClipboardHistory = append(updatedClipboardHistory, entry)\n        }\n    }\n\n    updatedData := ClipboardHistory{\n        ClipboardHistory: updatedClipboardHistory,\n    }\n    updatedJSON, err := json.Marshal(updatedData)\n    if err != nil {\n        return fmt.Errorf(\"error marshalling JSON: %w\", err)\n    }\n\n    // Write the updated JSON back to the file\n    if err := os.WriteFile(filePath, updatedJSON, 0644); err != nil {\n        return fmt.Errorf(\"error writing file: %w\", err)\n    }\n\n    return nil\n}\n\nfunc main() {\n\trand.Seed(time.Now().UTC().UnixNano())\n\tif _, err := tea.NewProgram(newModel()).Run(); err != nil {\n\t\tfmt.Println(\"Error opening clipboard:\", err)\n\t\tos.Exit(1)\n\t}\n}","recorded":"2024-02-11 00:29:44.55808 +0000 UTC"},{"value":"SelectedItem","recorded":"2024-02-11 00:32:18.259909 +0000 UTC"},{"value":"\"github.com/charmbracelet/bubbles/key\"","recorded":"2024-02-11 00:32:31.660029 +0000 UTC"},{"value":"\t// Setup list\n\tdelegate := newItemDelegate(delegateKeys)\n\tclipboardList := list.New(entryItems, delegate, 0, 0)\n\tclipboardList.Title = \"Clipboard History\"\n\tclipboardList.Styles.Title = titleStyle\n\tclipboardList.AdditionalFullHelpKeys = func() []key.Binding {\n\t\treturn []key.Binding{\n\t\t\tlistKeys.toggleSpinner,\n\t\t\tlistKeys.toggleTitleBar,\n\t\t\tlistKeys.toggleStatusBar,\n\t\t\tlistKeys.togglePagination,\n\t\t\tlistKeys.toggleHelpMenu,\n\t\t}\n\t}\n\n\treturn model{\n\t\tlist:          clipboardList,\n\t\tkeys:          listKeys,\n\t\tdelegateKeys:  delegateKeys,\n\t}\n}","recorded":"2024-02-11 00:32:44.044385 +0000 UTC"},{"value":"\n\t\"github.com/atotto/clipboard\"\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/list\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n)","recorded":"2024-02-11 13:34:06.43210546 +0000 UTC"},{"value":"package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/atotto/clipboard\"\n)\n\n// Data struct for storing clipboard strings\ntype Data struct {\n\tClipboardHistory []ClipboardItem `json:\"clipboardHistory\"`\n}\n\n// ClipboardItem struct for individual clipboard history item\ntype ClipboardItem struct {\n\tValue    string `json:\"value\"`\n\tRecorded string `json:\"recorded\"`\n}\n\nfunc main() {\n\t// Listen for SIGINT (Ctrl+C) and SIGTERM signals to properly close the program\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, syscall.SIGINT, syscall.SIGTERM)\n\n\t// Load existing data from file, if any\n\tvar data Data\n\terr := loadDataFromFile(\"../history.json\", \u0026data)\n\tif err != nil {\n\t\tfmt.Println(\"Error loading data from file:\", err)\n\t}\n\n\t// Start a goroutine to continuously monitor clipboard changes\n\tgo func() {\n\t\tfor {\n\t\t\t// Get the current clipboard content\n\t\t\ttext, err := clipboard.ReadAll()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading clipboard:\", err)\n\t\t\t}\n\n\t\t\t// If clipboard content is not empty and not already in the list, add it\n\t\t\tif text != \"\" \u0026\u0026 !contains(data.ClipboardHistory, text) {\n\t\t\t\t// If the length exceeds 50, remove the oldest item\n\t\t\t\tif len(data.ClipboardHistory) \u003e= 50 {\n\t\t\t\t\tdata.ClipboardHistory = data.ClipboardHistory[1:] // Remove the oldest item (first element)\n\t\t\t\t}\n\t\t\t\ttimeNow := time.Now().UTC().String()\n\t\t\t\titem := ClipboardItem{Value: text, Recorded: timeNow}\n\t\t\t\tdata.ClipboardHistory = append(data.ClipboardHistory, item)\n\t\t\t\tfmt.Println(\"Added to clipboard history:\", text)\n\n\t\t\t\t// Save data to file\n\t\t\t\terr := saveDataToFile(\"../history.json\", data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Println(\"Error saving data to file:\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for updates every second\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}()\n\n\tfmt.Println(\"Clipboard history listener running... Press Ctrl+C to exit.\")\n\n\t// Wait for SIGINT or SIGTERM signal\n\t\u003c-interrupt\n\tfmt.Println(\"Exiting...\")\n}\n\n// contains checks if a string exists in a slice of strings\nfunc contains(slice []ClipboardItem, str string) bool {\n\tfor _, item := range slice {\n\t\tif item.Value == str {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// loadDataFromFile loads data from a JSON file\nfunc loadDataFromFile(filename string, data *Data) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tdecoder := json.NewDecoder(file)\n\terr = decoder.Decode(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// saveDataToFile saves data to a JSON file\nfunc saveDataToFile(filename string, data Data) error {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tencoder := json.NewEncoder(file)\n\terr = encoder.Encode(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n","recorded":"2024-02-11 13:34:51.70148861 +0000 UTC"},{"value":"\"github.com/atotto/clipboard\"","recorded":"2024-02-11 13:49:04.633196562 +0000 UTC"},{"value":"time.Sleep(time.Second)","recorded":"2024-02-11 13:54:47.510406749 +0000 UTC"},{"value":"duration := 100 * time.Millisecond / 10 ","recorded":"2024-02-11 13:56:23.043456593 +0000 UTC"},{"value":"Millisecond","recorded":"2024-02-11 13:56:50.023923212 +0000 UTC"},{"value":"history","recorded":"2024-02-11 13:56:51.789770639 +0000 UTC"},{"value":"running","recorded":"2024-02-11 13:56:53.22252049 +0000 UTC"},{"value":"Press","recorded":"2024-02-11 13:56:55.625657797 +0000 UTC"},{"value":"func newModel() model {\n\tvar (\n\t\tdelegateKeys = newDelegateKeyMap()\n\t\tlistKeys     = newListKeyMap()\n\t)\n\n\t// Make initial list of items\n\tclipboardItems := getjsonData()\n\tvar entryItems []list.Item\n\tfor _, entry := range clipboardItems {\n\t\tshortenedVal := shorten(entry.Value)\n\t\titem := item{\n\t\t\ttitle:       shortenedVal,\n\t\t\ttitleFull:   entry.Value,\n\t\t\tdescription: \"Copied to clipboard: \" + entry.Recorded,\n\t\t}\n\t\tentryItems = append(entryItems, item)\n\t}\n\n\t// Setup list\n\tdelegate := newItemDelegate(delegateKeys)\n\tclipboardList := list.New(entryItems, delegate, 0, 0)\n\tclipboardList.Title = \"Clipboard History\"\n\tclipboardList.Styles.Title = titleStyle\n\tclipboardList.AdditionalFullHelpKeys = func() []key.Binding {\n\t\treturn []key.Binding{\n\t\t\tlistKeys.toggleSpinner,\n\t\t\tlistKeys.toggleTitleBar,\n\t\t\tlistKeys.toggleStatusBar,\n\t\t\tlistKeys.togglePagination,\n\t\t\tlistKeys.toggleHelpMenu,\n\t\t}\n\t}\n\n\treturn model{\n\t\tlist:         clipboardList,\n\t\tkeys:         listKeys,\n\t\tdelegateKeys: delegateKeys,\n\t}\n}","recorded":"2024-02-11 13:57:46.947587469 +0000 UTC"},{"value":"go func() {\n\t\tfor {\n\t\t\t// Get the current clipboard content\n\t\t\ttext, err := clipboard.ReadAll()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading clipboard:\", err)\n\t\t\t}\n\n\t\t\t// If clipboard content is not empty and not already in the list, add it\n\t\t\tif text != \"\" \u0026\u0026 !contains(data.ClipboardHistory, text) {\n\t\t\t\t// If the length exceeds 50, remove the oldest item\n\t\t\t\tif len(data.ClipboardHistory) \u003e= 50 {\n\t\t\t\t\tdata.ClipboardHistory = data.ClipboardHistory[1:] // Remove the oldest item (first element)\n\t\t\t\t}\n\t\t\t\ttimeNow := time.Now().UTC().String()\n\t\t\t\titem := ClipboardItem{Value: text, Recorded: timeNow}\n\t\t\t\tdata.ClipboardHistory = append(data.ClipboardHistory, item)\n\t\t\t\tfmt.Println(\"Added to clipboard history:\", text)\n\n\t\t\t\t// Save data to file\n\t\t\t\terr := saveDataToFile(\"../history.json\", data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Println(\"Error saving data to file:\", err)\n\t\t\t\t}\n\t\t\t}","recorded":"2024-02-11 14:07:28.852055381 +0000 UTC"},{"value":"func reverseArray(arr []int) {\n    for i := 0; i \u003c len(arr)/2; i++ {\n        j := len(arr) - 1 - i\n        arr[i], arr[j] = arr[j], arr[i]\n    }\n}","recorded":"2024-02-11 14:11:05.542055324 +0000 UTC"},{"value":"item","recorded":"2024-02-11 14:12:07.295652595 +0000 UTC"},{"value":"[]map[string]string{newItem}","recorded":"2024-02-11 14:15:29.112329504 +0000 UTC"}]}
